/* eslint-disable */
/** Generated by scripts/generate-openapi.mjs. Do not edit manually. */
export interface paths {
  '/fleet/layout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve layout metadata for Fleet UI modules.
     * @description Returns the list of modules the UI should render and their exposed capabilities.
     */
    get: operations['getFleetLayout'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/fleet/state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve summarized state for the dashboard view.
     * @description Aggregates the latest audio, video, Zigbee, and camera status into a single payload for the dashboard.
     */
    get: operations['getFleetState'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/audio/devices': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List registered audio devices.
     * @description Returns a paginated list of audio players and their latest telemetry.
     */
    get: operations['listAudioDevices'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/audio/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve status for a specific audio device.
     * @description Fetches the real-time playback, volume, and connectivity status for a single audio player.
     */
    get: operations['getAudioDevice'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/audio/{id}/play': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start playback on an audio device.
     * @description Requests the player to begin playback from either the live stream or cached fallback file.
     */
    post: operations['playAudioDevice'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/audio/{id}/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Stop playback on an audio device.
     * @description Immediately halts playback and reports the resulting idle state for the device.
     */
    post: operations['stopAudioDevice'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/audio/{id}/volume': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Adjust playback volume for an audio device.
     * @description Sets the absolute gain multiplier on the target player (0.0â€“2.0 range).
     */
    post: operations['setAudioDeviceVolume'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/audio/{id}/config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Update persistent configuration for an audio device.
     * @description Persists stream URLs, fallback behaviour, and default source selection for a player.
     */
    put: operations['updateAudioDeviceConfig'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/video/tv': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve the current TV state.
     * @description Reports the TV's power, input, volume, and mute status via the backend CEC adapter.
     */
    get: operations['getTvStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/video/tv/power': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Toggle TV power state.
     * @description Sends a CEC command to turn the TV on or off and returns the updated status snapshot.
     */
    post: operations['setTvPower'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/video/tv/input': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Change the active TV input.
     * @description Switches the HDMI input using CEC and yields the refreshed device status.
     */
    post: operations['setTvInput'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/video/tv/volume': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Set the absolute TV volume level.
     * @description Issues an absolute volume command and returns the post-change TV status payload.
     */
    post: operations['setTvVolume'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/video/tv/mute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Toggle TV mute state.
     * @description Updates the mute flag through CEC commands and returns the latest status snapshot.
     */
    post: operations['setTvMute'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/zigbee/devices': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Zigbee devices with their latest state.
     * @description Provides a paginated list of Zigbee switches, sensors, and lights with recent telemetry.
     */
    get: operations['listZigbeeDevices'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/zigbee/devices/{id}/action': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Execute a control action on a Zigbee device.
     * @description Sends toggle, on/off, or scene commands to a Zigbee endpoint and reports the updated device state.
     */
    post: operations['runZigbeeDeviceAction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/camera/summary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve aggregated camera health and storage information.
     * @description Summarises camera online/offline status and recording storage utilisation.
     */
    get: operations['getCameraSummary'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/camera/events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List recent camera events.
     * @description Provides paginated camera motion/offline events with optional time filtering.
     */
    get: operations['listCameraEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/camera/preview/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Generate a temporary preview URL for a camera feed.
     * @description Issues a signed URL for live preview playback when available for the requested camera.
     */
    get: operations['getCameraPreview'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/health/summary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fleet-wide health summary for observability panel.
     * @description Collates module health states, marking degraded components and timestamping the snapshot.
     */
    get: operations['getHealthSummary'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/events/recent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve recent cross-module events for the activity feed.
     * @description Returns a flattened, paginated activity feed across all Fleet subsystems.
     */
    get: operations['getRecentEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    Error: {
      /**
       * @description Machine-readable error code.
       * @example AUDIO_DEVICE_TIMEOUT
       */
      code: string;
      /**
       * @description Human-readable summary of the error.
       * @example Audio player pi-audio-01 timed out while responding.
       */
      message: string;
      /**
       * @description Optional client-facing recommendation.
       * @example Retry in a few seconds or check device connectivity.
       */
      hint?: string;
      /**
       * @description Correlates the request across systems.
       * @example 14d6f1fd-4c9f-4e8d-8621-9254cb59aa81
       */
      correlationId: string;
      /**
       * @description Additional contextual information.
       * @example {
       *       "deviceId": "pi-audio-01",
       *       "timeoutMs": 4000
       *     }
       */
      details?: {
        [key: string]: unknown;
      } | null;
    };
    FleetLayout: {
      /**
       * Format: date-time
       * @description Timestamp when the layout was generated.
       */
      updatedAt: string;
      modules: components['schemas']['LayoutModule'][];
    };
    LayoutModule: {
      /**
       * @description Stable module identifier.
       * @example audio
       */
      id: string;
      /** @example Audio Players */
      displayName: string;
      /** @description Whether the module is currently enabled in the UI. */
      enabled: boolean;
      /** @example Controls for distributed audio zones. */
      description?: string | null;
      /** @example [
       *       "playback",
       *       "volume",
       *       "configuration"
       *     ] */
      capabilities: string[];
    };
    FleetState: {
      /** Format: date-time */
      generatedAt: string;
      audio: {
        devices: components['schemas']['AudioDeviceStatus'][];
      };
      video: {
        tv: components['schemas']['TvStatus'];
      };
      zigbee: components['schemas']['ZigbeeStateSummary'];
      camera: components['schemas']['CameraStateSummary'];
    };
    AudioDeviceStatus: {
      /** @example pi-audio-01 */
      id: string;
      /** @example Lobby Speakers */
      displayName: string;
      online: boolean;
      playback: components['schemas']['AudioPlaybackState'];
      volume: components['schemas']['AudioVolumeState'];
      /** Format: date-time */
      lastSeen: string;
      /**
       * @description Supported control surfaces exposed by the device.
       * @example [
       *       "play",
       *       "stop",
       *       "volume",
       *       "upload"
       *     ]
       */
      capabilities?: string[];
      config?: components['schemas']['AudioConfigState'];
    };
    AudioPlaybackState: {
      /**
       * @description Current playback state.
       * @example playing
       * @enum {string}
       */
      state: 'idle' | 'playing' | 'buffering' | 'error';
      /**
       * @description Active audio source.
       * @enum {string}
       */
      source: 'stream' | 'file';
      /** @example Ambient Lobby Stream */
      trackTitle?: string | null;
      /** Format: date-time */
      since?: string | null;
      errorMessage?: string | null;
    };
    AudioVolumeState: {
      /**
       * Format: float
       * @example 0.85
       */
      level: number;
      /**
       * @description Whether the device volume is currently hardware locked.
       * @default false
       */
      locked: boolean;
      /** @example ui */
      lastChangedBy?: string | null;
    };
    AudioConfigState: {
      /** Format: uri */
      streamUrl?: string | null;
      /**
       * @description Device operating mode.
       * @example live
       */
      mode?: string | null;
      /** @enum {string|null} */
      defaultSource?: 'stream' | 'file' | null;
    };
    AudioDeviceList: {
      items: components['schemas']['AudioDeviceStatus'][];
      nextCursor?: string | null;
    };
    AudioPlayRequest: {
      /** @enum {string} */
      source: 'stream' | 'file';
      /**
       * @description Resume previous playback position when available.
       * @default false
       */
      resume: boolean;
    };
    AudioStopResponse: {
      id: string;
      playback: components['schemas']['AudioPlaybackState'];
    };
    AudioVolumeRequest: {
      /**
       * Format: float
       * @example 1
       */
      volume: number;
    };
    AudioVolumeResponse: components['schemas']['AudioDeviceStatus'];
    AudioConfigRequest: {
      /** Format: uri */
      streamUrl?: string;
      /** @enum {string} */
      mode?: 'live' | 'fallback';
      /** @enum {string} */
      source?: 'stream' | 'file';
    };
    AudioConfigResponse: components['schemas']['AudioDeviceStatus'];
    TvStatus: {
      /** @example tv-main-hall */
      id: string;
      /** @example Main Hall TV */
      displayName: string;
      online: boolean;
      /** @enum {string} */
      power: 'on' | 'off';
      /** @example HDMI1 */
      input: string;
      /** @example [
       *       "HDMI1",
       *       "HDMI2",
       *       "HDMI3"
       *     ] */
      availableInputs?: string[];
      volume: number;
      mute: boolean;
      /** Format: date-time */
      lastSeen: string;
    };
    TvPowerRequest: {
      on: boolean;
    };
    TvInputRequest: {
      /** @example HDMI2 */
      input: string;
    };
    TvVolumeRequest: {
      level: number;
    };
    TvMuteRequest: {
      mute: boolean;
    };
    ZigbeeStateSummary: {
      coordinatorOnline: boolean;
      devicesOnline: number;
      totalDevices: number;
      /** @example [
       *       "evening",
       *       "away"
       *     ] */
      scenesAvailable?: string[];
    };
    ZigbeeDeviceList: {
      items: components['schemas']['ZigbeeDeviceSummary'][];
      nextCursor?: string | null;
    };
    ZigbeeDeviceSummary: {
      /** @example zigbee-switch-01 */
      id: string;
      /** @example Lobby Lighting */
      displayName: string;
      /** @example switch */
      type: string;
      /** @example on */
      state: string;
      batteryPercent?: number | null;
      /** Format: date-time */
      lastSeen?: string;
    };
    ZigbeeActionRequest: {
      /** @enum {string} */
      action: 'toggle' | 'on' | 'off' | 'scene';
      /** @description Required when action is scene. */
      scene?: string | null;
    };
    CameraStateSummary: {
      totalCameras: number;
      onlineCameras: number;
      recordingCameras: number;
      motionEventsToday?: number;
      /** Format: date-time */
      lastEventAt?: string | null;
    };
    CameraSummary: {
      cameras: components['schemas']['CameraSummaryItem'][];
      storage: components['schemas']['CameraStorageSummary'];
    };
    CameraSummaryItem: {
      /** @example cam-lobby-01 */
      id: string;
      /** @example Lobby Entrance */
      displayName: string;
      online: boolean;
      recording: boolean;
      /** Format: date-time */
      lastEventAt?: string | null;
    };
    CameraStorageSummary: {
      usedPercent: number;
      retentionDays: number;
    };
    CameraEvents: {
      items: components['schemas']['CameraEvent'][];
      nextCursor?: string | null;
    };
    CameraEvent: {
      /** @example evt-20240101-01 */
      id: string;
      /** @example cam-lobby-01 */
      cameraId: string;
      /** @example motion */
      type: string;
      /** @enum {string} */
      severity?: 'info' | 'warning' | 'critical';
      /** Format: date-time */
      timestamp: string;
      /** Format: uri */
      clipUrl?: string | null;
      /** Format: uri */
      thumbnailUrl?: string | null;
      synopsis?: string | null;
    };
    CameraPreview: {
      cameraId: string;
      /** Format: uri */
      url: string;
      /** Format: date-time */
      expiresAt?: string;
    };
    HealthSummary: {
      /** @enum {string} */
      status: 'healthy' | 'degraded' | 'down';
      /** Format: date-time */
      updatedAt: string;
      modules: components['schemas']['ModuleHealth'][];
    };
    ModuleHealth: {
      /** @example audio */
      id: string;
      /** @enum {string} */
      status: 'healthy' | 'degraded' | 'down';
      /** @example 1 device offline (pi-audio-02) */
      message?: string | null;
    };
    RecentEvents: {
      items: components['schemas']['RecentEvent'][];
      nextCursor?: string | null;
    };
    RecentEvent: {
      id: string;
      /** @example audio */
      source: string;
      /** @example Lobby Speakers playback resumed */
      title: string;
      /** @enum {string} */
      severity: 'info' | 'warning' | 'critical';
      /** Format: date-time */
      timestamp: string;
      correlationId?: string | null;
    };
  };
  responses: {
    /** @description Authentication credentials missing or invalid. */
    UnauthorizedError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Authenticated user lacks required scope. */
    ForbiddenError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Requested resource could not be found. */
    NotFoundError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Request payload failed validation. */
    ValidationError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Resource is in a conflicting state. */
    ConflictError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Request rate limit exceeded. */
    RateLimitError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        'x-ratelimit-limit': components['headers']['RateLimitLimit'];
        'x-ratelimit-remaining': components['headers']['RateLimitRemaining'];
        'retry-after': components['headers']['RetryAfterSeconds'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Upstream device returned an invalid response or is unreachable. */
    BadGatewayError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Upstream device timed out while processing the request. */
    GatewayTimeoutError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Unexpected server error occurred. */
    InternalError: {
      headers: {
        'x-correlation-id': components['headers']['CorrelationId'];
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
  };
  parameters: {
    /** @description Maximum number of results to return. */
    LimitParam: number;
    /** @description Opaque pagination cursor returned by previous responses. */
    CursorParam: string;
    /** @description Filter events to those occurring at or after the ISO-8601 timestamp. */
    SinceParam: string;
    /** @description Maximum number of events to return. */
    EventsLimitParam: number;
  };
  requestBodies: never;
  headers: {
    /** @description Correlation identifier for tracing requests end-to-end. */
    CorrelationId: string;
    /** @description Maximum number of requests allowed in the current window. */
    RateLimitLimit: number;
    /** @description Remaining requests in the current window. */
    RateLimitRemaining: number;
    /** @description Seconds until clients may retry after a 429 response. */
    RetryAfterSeconds: number;
  };
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  getFleetLayout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Layout information for all modules. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FleetLayout'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      500: components['responses']['InternalError'];
    };
  };
  getFleetState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Summarized fleet state. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FleetState'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      500: components['responses']['InternalError'];
    };
  };
  listAudioDevices: {
    parameters: {
      query?: {
        /** @description Maximum number of results to return. */
        limit?: components['parameters']['LimitParam'];
        /** @description Opaque pagination cursor returned by previous responses. */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Collection of audio devices. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AudioDeviceList'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  getAudioDevice: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Audio device identifier. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Current device status. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AudioDeviceStatus'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      404: components['responses']['NotFoundError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  playAudioDevice: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AudioPlayRequest'];
      };
    };
    responses: {
      /** @description Updated device status after triggering playback. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AudioDeviceStatus'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      404: components['responses']['NotFoundError'];
      /** @description Device busy and cannot accept playback command. */
      409: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
      422: components['responses']['ValidationError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  stopAudioDevice: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Playback halted. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AudioStopResponse'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      404: components['responses']['NotFoundError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  setAudioDeviceVolume: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AudioVolumeRequest'];
      };
    };
    responses: {
      /** @description Updated device volume state. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AudioVolumeResponse'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      404: components['responses']['NotFoundError'];
      422: components['responses']['ValidationError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  updateAudioDeviceConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AudioConfigRequest'];
      };
    };
    responses: {
      /** @description Updated device configuration and status. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AudioConfigResponse'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      404: components['responses']['NotFoundError'];
      /** @description Device busy updating configuration. */
      409: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
      422: components['responses']['ValidationError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  getTvStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description TV status details. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TvStatus'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  setTvPower: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TvPowerRequest'];
      };
    };
    responses: {
      /** @description Updated TV status. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TvStatus'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      /** @description TV is already processing another command. */
      409: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Error'];
        };
      };
      422: components['responses']['ValidationError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  setTvInput: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TvInputRequest'];
      };
    };
    responses: {
      /** @description Updated TV status. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TvStatus'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      409: components['responses']['ConflictError'];
      422: components['responses']['ValidationError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  setTvVolume: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TvVolumeRequest'];
      };
    };
    responses: {
      /** @description Updated TV status including volume details. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TvStatus'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      422: components['responses']['ValidationError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  setTvMute: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TvMuteRequest'];
      };
    };
    responses: {
      /** @description Updated TV status. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TvStatus'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  listZigbeeDevices: {
    parameters: {
      query?: {
        /** @description Maximum number of results to return. */
        limit?: components['parameters']['LimitParam'];
        /** @description Opaque pagination cursor returned by previous responses. */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Zigbee device collection. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ZigbeeDeviceList'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  runZigbeeDeviceAction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ZigbeeActionRequest'];
      };
    };
    responses: {
      /** @description Action accepted. */
      202: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ZigbeeDeviceSummary'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      404: components['responses']['NotFoundError'];
      409: components['responses']['ConflictError'];
      422: components['responses']['ValidationError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  getCameraSummary: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Camera summary data. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CameraSummary'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  listCameraEvents: {
    parameters: {
      query?: {
        /** @description Maximum number of events to return. */
        limit?: components['parameters']['EventsLimitParam'];
        /** @description Opaque pagination cursor returned by previous responses. */
        cursor?: components['parameters']['CursorParam'];
        /** @description Filter events to those occurring at or after the ISO-8601 timestamp. */
        since?: components['parameters']['SinceParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Recent camera events. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CameraEvents'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  getCameraPreview: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Preview URL for the requested camera. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CameraPreview'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      404: components['responses']['NotFoundError'];
      429: components['responses']['RateLimitError'];
      502: components['responses']['BadGatewayError'];
      504: components['responses']['GatewayTimeoutError'];
    };
  };
  getHealthSummary: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Health information for modules. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HealthSummary'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      500: components['responses']['InternalError'];
    };
  };
  getRecentEvents: {
    parameters: {
      query?: {
        /** @description Maximum number of events to return. */
        limit?: components['parameters']['EventsLimitParam'];
        /** @description Opaque pagination cursor returned by previous responses. */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Recent fleet events. */
      200: {
        headers: {
          'x-correlation-id': components['headers']['CorrelationId'];
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RecentEvents'];
        };
      };
      401: components['responses']['UnauthorizedError'];
      403: components['responses']['ForbiddenError'];
      429: components['responses']['RateLimitError'];
      500: components['responses']['InternalError'];
    };
  };
}
