/* eslint-disable */
/** Generated by scripts/generate-openapi.mjs. Do not edit manually. */
export interface paths {
    "/fleet/layout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve fleet layout metadata for UI composition.
         * @description Retrieve fleet layout metadata for UI composition.
         */
        get: operations["getFleetLayout"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/fleet/overview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve aggregate fleet status for operator dashboards.
         * @description Retrieve aggregate fleet status for operator dashboards.
         */
        get: operations["getFleetOverview"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/fleet/devices/{deviceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve detailed status, metrics, and actions for a fleet device.
         * @description Retrieve detailed status, metrics, and actions for a fleet device.
         */
        get: operations["getFleetDeviceDetail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/fleet/devices/{deviceId}/actions/{actionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger a quick action on a fleet device.
         * @description Trigger a quick action on a fleet device.
         */
        post: operations["triggerFleetDeviceAction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/overview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve consolidated audio state including devices, playlists, and sessions.
         * @description Retrieve consolidated audio state including devices, playlists, and sessions.
         */
        get: operations["getAudioOverview"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/library": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload a new track to the audio library.
         * @description Upload a new track to the audio library.
         */
        post: operations["uploadAudioTrack"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/library/uploads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register a pending upload for an audio library track.
         * @description Register a pending upload for an audio library track. Returns signed upload parameters for the UI.
         */
        post: operations["registerAudioUpload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/playlists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List audio playlists configured for distributed playback.
         * @description Retrieve ordered playlists available to the operator workspace with track metadata.
         */
        get: operations["listAudioPlaylists"];
        put?: never;
        /**
         * Create a new audio playlist.
         * @description Create a new audio playlist.
         */
        post: operations["createAudioPlaylist"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/playlists/{playlistId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update an existing audio playlist.
         * @description Update an existing audio playlist.
         */
        put: operations["updateAudioPlaylist"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/playlists/{playlistId}/reorder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reorder tracks within a playlist without modifying metadata.
         * @description Update the track ordering for an existing playlist by supplying a new ordered list of track identifiers.
         */
        post: operations["reorderAudioPlaylist"];
        /**
         * Delete an existing audio playlist.
         * @description Delete an existing audio playlist.
         */
        delete: operations["deleteAudioPlaylist"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/playback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Initiate playback across one or more audio devices.
         * @description Initiate playback across one or more audio devices.
         */
        post: operations["startAudioPlayback"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/devices/{deviceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve the latest snapshot for an individual audio device.
         * @description Retrieve the latest snapshot for an individual audio device.
         */
        get: operations["getAudioDevice"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/devices/{deviceId}/pause": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Pause playback on an audio device.
         * @description Pause playback on an audio device.
         */
        post: operations["pauseAudioDevice"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/playback/sessions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List recent audio playback sessions and their current state.
         * @description Provide historical playback session data for operators monitoring sync and device cohorts.
         */
        get: operations["listAudioPlaybackSessions"];
        put?: never;
        /**
         * Create and start a new coordinated playback session.
         * @description Launch a playback session spanning multiple devices with optional sync and playlist configuration.
         */
        post: operations["createAudioPlaybackSession"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/playback/sessions/{sessionId}/sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Report drift metrics for a playback session to drive resynchronisation.
         * @description Submit drift telemetry captured by the UI so the backend can record the latest synchronisation context.
         */
        post: operations["syncAudioPlaybackSession"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/devices/{deviceId}/resume": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Resume playback on an audio device.
         * @description Resume playback on an audio device.
         */
        post: operations["resumeAudioDevice"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/devices/{deviceId}/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop playback on an audio device.
         * @description Stop playback on an audio device.
         */
        post: operations["stopAudioDevice"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/devices/{deviceId}/seek": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Seek to a position in the currently playing track.
         * @description Seek to a position in the currently playing track.
         */
        post: operations["seekAudioDevice"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/devices/{deviceId}/volume": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set the volume for an audio device.
         * @description Set the volume for an audio device.
         */
        post: operations["setAudioDeviceVolume"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/devices/{deviceId}/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload a fallback audio file to an audio device.
         * @description Forward a multipart upload to the target device which atomically replaces `/data/fallback.mp3`.
         */
        post: operations["uploadAudioDeviceFallback"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/master-volume": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set the global master volume for audio playback.
         * @description Set the global master volume for audio playback.
         */
        post: operations["setAudioMasterVolume"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Zigbee automation rules.
         * @description Retrieve all configured Zigbee automation rules with trigger and action metadata.
         */
        get: operations["listZigbeeRules"];
        put?: never;
        /**
         * Create a new Zigbee automation rule.
         * @description Persist a Zigbee automation rule that links triggers to downstream actions.
         */
        post: operations["createZigbeeRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/rules/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Validate a Zigbee automation rule definition.
         * @description Validate a Zigbee automation rule definition without persisting it.
         */
        post: operations["validateZigbeeRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/rules/simulate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Simulate execution of a Zigbee automation rule.
         * @description Evaluate a Zigbee automation rule against sample trigger input within a sandbox.
         */
        post: operations["simulateZigbeeRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/rules/{ruleId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Zigbee automation rule.
         * @description Fetch metadata for a specific Zigbee automation rule by identifier.
         */
        get: operations["getZigbeeRule"];
        /**
         * Update a Zigbee automation rule.
         * @description Replace fields on an existing Zigbee automation rule.
         */
        put: operations["updateZigbeeRule"];
        post?: never;
        /**
         * Delete a Zigbee automation rule.
         * @description Remove a Zigbee automation rule and disable associated automations.
         */
        delete: operations["deleteZigbeeRule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/rules/{ruleId}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Toggle a Zigbee automation rule.
         * @description Enable or disable a Zigbee automation rule without modifying other metadata.
         */
        patch: operations["toggleZigbeeRule"];
        trace?: never;
    };
    "/video/overview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve consolidated video device status.
         * @description Retrieve consolidated video device status.
         */
        get: operations["getVideoOverview"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/video/devices": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List managed video devices and their current state.
         * @description Enumerate video endpoints, including power, mute, and input state for the operator dashboard.
         */
        get: operations["listVideoDevices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/video/devices/{deviceId}/power": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set the power state of a video endpoint.
         * @description Issue power on or standby commands to a managed display or switcher.
         */
        post: operations["setVideoPower"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/video/devices/{deviceId}/mute": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Update mute state for a video device.
         * @description Toggle the audio mute flag for the specified video endpoint.
         */
        post: operations["setVideoMute"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/video/devices/{deviceId}/input": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Switch the active input on a video device.
         * @description Change the current input selection on a display or receiver.
         */
        post: operations["setVideoInput"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/video/recordings/{recordingId}/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request an export of a recording clip for download.
         * @description Submit an export intent for a recorded segment, returning tracking metadata and a download URL when ready.
         */
        post: operations["exportVideoClip"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/video/recordings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve recording segments for the active video source.
         * @description Retrieve recording segments for the active video source.
         */
        get: operations["getVideoRecordings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/video/preview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate a signed URL for a live video preview stream.
         * @description Generate a signed URL for a live video preview stream.
         */
        post: operations["generateVideoPreview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/overview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve Zigbee hub state, devices, and quick actions.
         * @description Retrieve Zigbee hub state, devices, and quick actions.
         */
        get: operations["getZigbeeOverview"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/devices/{deviceId}/action": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute a quick action on a Zigbee device.
         * @description Execute a quick action on a Zigbee device.
         */
        post: operations["runZigbeeAction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/pairing": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Zigbee pairing mode for discovering new devices.
         * @description Start Zigbee pairing mode for discovering new devices.
         */
        post: operations["startZigbeePairing"];
        /**
         * Stop Zigbee pairing mode.
         * @description Stop Zigbee pairing mode.
         */
        delete: operations["stopZigbeePairing"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/pairing/discovered": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Poll for newly discovered Zigbee devices during pairing mode.
         * @description Poll for newly discovered Zigbee devices during pairing mode.
         */
        get: operations["pollZigbeeDiscovered"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/zigbee/pairing/{deviceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Confirm pairing of a discovered Zigbee device.
         * @description Confirm pairing of a discovered Zigbee device.
         */
        post: operations["confirmZigbeePairing"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/camera/summary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve consolidated camera state for the operator dashboard.
         * @description Retrieve consolidated camera state for the operator dashboard.
         */
        get: operations["getCameraSummary"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/camera/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List camera AI events with optional filters.
         * @description Retrieve camera detections with support for time range, confidence, and tag filtering.
         */
        get: operations["listCameraEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/camera/events/{eventId}/ack": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Mark a camera event as acknowledged.
         * @description Mark a camera event as acknowledged.
         */
        post: operations["acknowledgeCameraEvent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/camera/preview/{cameraId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve preview status for a camera.
         * @description Retrieve preview readiness for a specific camera including offline reasons.
         */
        get: operations["getCameraPreview"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/camera/streams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List camera stream metadata and availability.
         * @description Enumerate camera streams, providing status and offline reasons for monitoring.
         */
        get: operations["listCameraStreams"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a snapshot of recent logs with optional filtering.
         * @description Retrieve a snapshot of recent logs with optional filtering.
         */
        get: operations["getLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logs/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Subscribe to the live event stream of log entries.
         * @description Subscribe to the live event stream of log entries.
         */
        get: operations["streamLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logs/query": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a filtered slice of logs for operator review.
         * @description Fetch recent log lines matching severity, device, and correlation filters for troubleshooting.
         */
        get: operations["queryLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logs/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create an export of logs matching a filter set.
         * @description Queue a downloadable log export job using optional filters for offline analysis.
         */
        post: operations["exportLogs"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logs/jobs/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve the status and download URL for a log export job.
         * @description Check the processing status of a log export job and get the download URL when ready.
         */
        get: operations["getLogExportJob"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve operator settings, proxy configuration, and pairing status.
         * @description Retrieve operator settings, proxy configuration, and pairing status.
         */
        get: operations["getSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/proxy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update proxy configuration settings.
         * @description Update proxy configuration settings.
         */
        patch: operations["updateProxySettings"];
        trace?: never;
    };
    "/settings/api-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Rotate the API bearer token used by operator integrations.
         * @description Rotate the API bearer token used by operator integrations.
         */
        post: operations["rotateApiToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/allowed-origins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Replace the list of allowed CORS origins for the API.
         * @description Replace the list of allowed CORS origins for the API.
         */
        put: operations["updateAllowedOrigins"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/pairing/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start operator pairing flow for onboarding new devices.
         * @description Start operator pairing flow for onboarding new devices.
         */
        post: operations["startSettingsPairing"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/pairing/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel an in-progress pairing flow.
         * @description Cancel an in-progress pairing flow.
         */
        post: operations["cancelSettingsPairing"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/pairing/{candidateId}/claim": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Claim a discovered device and record pairing outcome.
         * @description Claim a discovered device and record pairing outcome.
         */
        post: operations["claimPairingCandidate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/operators": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List operator accounts and roles.
         * @description Retrieve all operator accounts along with their roles and status metadata.
         */
        get: operations["listOperators"];
        put?: never;
        /**
         * Invite a new operator account with specified roles.
         * @description Invite a new operator account with specified roles.
         */
        post: operations["inviteOperator"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/operators/{operatorId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update an operator account.
         * @description Modify operator roles or status for an existing account.
         */
        put: operations["updateOperator"];
        post?: never;
        /**
         * Remove an operator account.
         * @description Remove an operator account.
         */
        delete: operations["removeOperator"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/security": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve security escalation settings.
         * @description Fetch night mode escalation preferences and alert channels.
         */
        get: operations["getSecuritySettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update security escalation settings.
         * @description Adjust night mode escalation toggle and alert delivery channels.
         */
        patch: operations["updateSecuritySettings"];
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Error: {
            /** @description Machine-readable error code. */
            code: string;
            /** @description Human-readable summary of the error. */
            message: string;
            /** @description Optional client-facing recommendation. */
            hint?: string | null;
            /**
             * Format: uuid
             * @description Correlates the request across systems.
             */
            correlationId: string;
            /** @description Additional contextual information for debugging. */
            details?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * @description Standard device status values aligned with the device capabilities matrix.
         * @enum {string}
         */
        DeviceStatus: "online" | "offline" | "error" | "degraded";
        /** @enum {string} */
        AudioPlaybackStateName: "idle" | "playing" | "paused" | "buffering" | "error";
        /** @enum {string} */
        AudioSyncMode: "independent" | "synced" | "grouped";
        AudioDevicePlayback: {
            state: components["schemas"]["AudioPlaybackStateName"];
            trackId?: string | null;
            trackTitle?: string | null;
            playlistId?: string | null;
            /** Format: float */
            positionSeconds: number;
            /** Format: float */
            durationSeconds: number;
            /** Format: date-time */
            startedAt: string | null;
            syncGroup: string | null;
            lastError?: string | null;
        };
        AudioDeviceSnapshot: {
            id: string;
            name: string;
            status: components["schemas"]["DeviceStatus"];
            group?: string | null;
            /**
             * Format: int32
             * @description Percent-based volume control, aligned with 1 dB steps in Pi devices.
             */
            volumePercent: number;
            /**
             * @description Capabilities exposed by the device. Values map to the live device capabilities matrix.
             * @example [
             *       "playback",
             *       "seek",
             *       "sync",
             *       "upload"
             *     ]
             */
            capabilities: string[];
            playback: components["schemas"]["AudioDevicePlayback"];
            /** Format: date-time */
            lastUpdated: string;
            /** @description Indicates whether a fallback file is currently stored on the device. */
            fallbackExists?: boolean;
        };
        AudioLibraryTrack: {
            id: string;
            title: string;
            artist?: string | null;
            /** Format: float */
            durationSeconds: number;
            /** @description Media container or codec (e.g. MP3, AAC, FLAC) supported per the device matrix. */
            format: string;
            /** Format: int64 */
            sizeBytes?: number | null;
            tags?: string[];
            /** Format: date-time */
            uploadedAt: string;
        };
        AudioPlaylistTrack: {
            trackId: string;
            /** Format: int32 */
            order: number;
            /** Format: float */
            startOffsetSeconds?: number | null;
            deviceOverrides?: {
                [key: string]: string;
            } | null;
        };
        AudioPlaylist: {
            id: string;
            name: string;
            description?: string | null;
            loop: boolean;
            syncMode: components["schemas"]["AudioSyncMode"];
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
            tracks: components["schemas"]["AudioPlaylistTrack"][];
        };
        AudioSession: {
            id: string;
            playlistId?: string | null;
            trackId?: string | null;
            deviceIds: string[];
            syncMode: components["schemas"]["AudioSyncMode"];
            /** @enum {string} */
            state: "preparing" | "playing" | "paused" | "completed" | "error";
            /** Format: date-time */
            startedAt: string;
            lastError?: string | null;
            drift?: components["schemas"]["AudioSessionDrift"];
        };
        AudioState: {
            /** Format: int32 */
            masterVolume: number;
            devices: components["schemas"]["AudioDeviceSnapshot"][];
            library: components["schemas"]["AudioLibraryTrack"][];
            playlists: components["schemas"]["AudioPlaylist"][];
            sessions: components["schemas"]["AudioSession"][];
            message?: string | null;
        };
        AudioPlaybackAssignment: {
            deviceId: string;
            trackId: string;
            /** Format: float */
            startOffsetSeconds?: number | null;
        };
        AudioPlaybackRequest: {
            deviceIds: string[];
            playlistId?: string | null;
            trackId?: string | null;
            assignments?: components["schemas"]["AudioPlaybackAssignment"][];
        };
        AudioPlaybackSessionCreateRequest: components["schemas"]["AudioPlaybackRequest"] & {
            /** @description Optional session label displayed in operator UI. */
            label?: string | null;
        };
        AudioPlaylistReorderRequest: {
            ordering: {
                trackId: string;
                /** Format: int32 */
                position: number;
            }[];
        };
        AudioSessionSyncRequest: {
            /** Format: date-time */
            referenceTimestamp: string;
            /** Format: float */
            maxDriftSeconds: number;
            perDevice: {
                [key: string]: number;
            };
            correctionsApplied?: boolean;
        };
        AudioSessionDrift: {
            /** Format: date-time */
            referenceTimestamp?: string | null;
            /** Format: float */
            maxDriftSeconds: number;
            perDevice: {
                [key: string]: number;
            };
            correctionsApplied?: boolean;
        };
        AudioLibraryUploadRegistrationRequest: {
            filename: string;
            /** @default application/octet-stream */
            contentType: string;
            /** Format: int64 */
            sizeBytes?: number;
            title?: string | null;
            artist?: string | null;
            tags?: string[];
            metadata?: {
                [key: string]: string;
            } | null;
        };
        AudioLibraryUploadRegistration: {
            uploadId: string;
            filename: string;
            contentType: string;
            /** Format: int64 */
            sizeBytes?: number | null;
            title?: string | null;
            artist?: string | null;
            tags?: string[];
            metadata?: {
                [key: string]: string;
            } | null;
            /** Format: uri */
            uploadUrl: string;
            /** Format: date-time */
            expiresAt: string;
        };
        AudioDeviceUploadResponse: {
            /** @description Identifier of the audio device that processed the upload. */
            deviceId: string;
            /** @description Indicates whether the device persisted the uploaded file. */
            saved: boolean;
            /** @description Absolute path reported by the device for the stored fallback asset. */
            path: string;
            /** @description Flag reflecting whether the device reports an on-disk fallback file after the upload. */
            fallbackExists: boolean;
            /** @description Raw status payload returned from the device following the upload. */
            status?: {
                stream_url: string;
                volume: number;
                /** @enum {string} */
                mode: "auto" | "manual";
                /** @enum {string} */
                source: "stream" | "file" | "stop";
                fallback_exists: boolean;
            };
            fields?: {
                [key: string]: string;
            };
            syncMode?: components["schemas"]["AudioSyncMode"];
            /** @default false */
            resume: boolean;
            /**
             * Format: float
             * @default 0
             */
            startAtSeconds: number;
            /** @default false */
            loop: boolean;
        };
        AudioSeekRequest: {
            /** Format: float */
            positionSeconds: number;
        };
        AudioVolumeRequest: {
            /**
             * Format: float
             * @description Normalised volume between 0.0 and 2.0 (inclusive).
             */
            volume: number;
        };
        AudioMasterVolumeRequest: {
            /** Format: int32 */
            volumePercent: number;
        };
        /** @enum {string} */
        VideoPowerState: "on" | "standby";
        VideoPreviewSession: {
            sessionId: string;
            /** Format: uri */
            streamUrl: string;
            /** Format: date-time */
            expiresAt: string;
            device?: {
                id?: string;
                name?: string;
                input?: string;
            } | null;
        };
        VideoClipExport: {
            exportId: string;
            recordingId: string;
            /** @enum {string} */
            status: "queued" | "processing" | "complete" | "failed";
            /** Format: float */
            startOffsetSeconds: number;
            /** Format: float */
            endOffsetSeconds: number;
            /** Format: date-time */
            requestedAt: string;
            /** Format: uri */
            downloadUrl: string;
        };
        VideoRecordingSegment: {
            id: string;
            deviceId: string;
            /** Format: date-time */
            startedAt: string;
            /** Format: date-time */
            endedAt: string;
            /** Format: int32 */
            durationSeconds: number;
            /** @enum {string} */
            status: "available" | "processing" | "failed";
        };
        VideoDeviceState: {
            id: string;
            name: string;
            module: string;
            role: string;
            status: string;
            power: components["schemas"]["VideoPowerState"];
            mute: boolean;
            input: string;
            /** Format: date-time */
            lastUpdated: string;
        };
        VideoOverview: {
            devices: components["schemas"]["VideoDeviceState"][];
            /** Format: int32 */
            total: number;
            /** Format: int32 */
            online: number;
            /** Format: date-time */
            updatedAt: string;
        };
        VideoPreviewRequest: {
            /** @description Target video node for generating the preview stream. */
            deviceId?: string;
        };
        ZigbeeDevice: {
            id: string;
            name: string;
            type: string;
            /** @enum {string} */
            state: "open" | "closed" | "active" | "inactive";
            /** Format: date-time */
            lastSeen: string;
            /** Format: int32 */
            battery?: number | null;
        };
        ZigbeePairingCandidate: {
            id: string;
            model: string;
            manufacturer: string;
            /** Format: int32 */
            signal: number;
            /** Format: date-time */
            lastSeen: string;
        };
        ZigbeePairingState: {
            active: boolean;
            /** Format: date-time */
            startedAt?: string | null;
            /** Format: date-time */
            expiresAt?: string | null;
            discovered: components["schemas"]["ZigbeePairingCandidate"][];
            confirmed?: string[];
        };
        ZigbeeState: {
            devices: components["schemas"]["ZigbeeDevice"][];
            hub: {
                id: string;
                status: string;
                /** Format: int32 */
                channel: number;
                /** Format: date-time */
                lastHeartbeatAt: string;
            };
            pairing: components["schemas"]["ZigbeePairingState"];
            rules: {
                id: string;
                name: string;
                enabled: boolean;
                /** Format: date-time */
                createdAt: string;
                /** Format: date-time */
                updatedAt: string;
            }[];
        };
        ZigbeeActionRequest: {
            deviceId: string;
            command: string;
            payload?: {
                [key: string]: string;
            };
        };
        ZigbeePairingStartRequest: {
            /** Format: int32 */
            durationSeconds?: number;
        };
        ZigbeeRuleCondition: {
            /** @description JSON pointer-style path evaluated against the trigger context payload. */
            field: string;
            /** @enum {string} */
            operator: "eq" | "neq" | "gt" | "gte" | "lt" | "lte" | "includes" | "excludes";
            value: string | number | boolean | (string | number | boolean)[];
        };
        ZigbeeRuleSensorTrigger: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "ZigbeeRuleSensorTrigger";
            sensorId: string;
            event: string;
            condition?: components["schemas"]["ZigbeeRuleCondition"];
            /** Format: int32 */
            cooldownSeconds?: number;
        };
        ZigbeeRuleScheduleTrigger: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "ZigbeeRuleScheduleTrigger";
            /** @description Cron expression evaluated by the hub scheduler. */
            cron: string;
            /** @description IANA timezone identifier used for the cron expression. */
            timezone?: string;
        };
        ZigbeeRuleExpressionTrigger: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "ZigbeeRuleExpressionTrigger";
            /** @description JavaScript expression evaluated in the automation sandbox. */
            expression: string;
            /**
             * @default js
             * @enum {string}
             */
            language: "js";
            description?: string;
        };
        ZigbeeRuleTrigger: components["schemas"]["ZigbeeRuleSensorTrigger"] | components["schemas"]["ZigbeeRuleScheduleTrigger"] | components["schemas"]["ZigbeeRuleExpressionTrigger"];
        ZigbeeRuleDeviceCommandAction: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "ZigbeeRuleDeviceCommandAction";
            deviceId: string;
            command: string;
            payload?: {
                [key: string]: unknown;
            };
        };
        ZigbeeRuleNotifyAction: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "ZigbeeRuleNotifyAction";
            /** @enum {string} */
            channel: "slack" | "email" | "sms";
            message: string;
            metadata?: {
                [key: string]: unknown;
            };
        };
        ZigbeeRuleDelayAction: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "ZigbeeRuleDelayAction";
            /** Format: int32 */
            durationSeconds: number;
        };
        ZigbeeRuleAction: components["schemas"]["ZigbeeRuleDeviceCommandAction"] | components["schemas"]["ZigbeeRuleNotifyAction"] | components["schemas"]["ZigbeeRuleDelayAction"];
        ZigbeeRuleDefinition: {
            name: string;
            description?: string;
            trigger: components["schemas"]["ZigbeeRuleTrigger"];
            actions: components["schemas"]["ZigbeeRuleAction"][];
            tags?: string[];
            metadata?: {
                [key: string]: unknown;
            };
            enabled?: boolean;
        };
        ZigbeeRuleUpdateRequest: {
            name?: string;
            description?: string | null;
            trigger?: components["schemas"]["ZigbeeRuleTrigger"];
            actions?: components["schemas"]["ZigbeeRuleAction"][];
            tags?: string[];
            metadata?: {
                [key: string]: unknown;
            };
            enabled?: boolean;
        };
        ZigbeeRule: components["schemas"]["ZigbeeRuleDefinition"] & {
            id: string;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
            description?: string | null;
            metadata?: {
                [key: string]: unknown;
            };
            tags?: string[];
        };
        ZigbeeRuleListResponse: {
            items: components["schemas"]["ZigbeeRule"][];
            /** Format: int32 */
            total: number;
        };
        ZigbeeRuleSimulationEvaluation: {
            triggerType: string;
            reason: string;
            error?: string | null;
            /** Format: date-time */
            startedAt: string;
            /** Format: date-time */
            completedAt: string;
            /** Format: int32 */
            durationMs: number;
        };
        /** @description Provide either an existing ruleId or a full definition to simulate. */
        ZigbeeRuleSimulationRequest: {
            ruleId?: string;
            definition?: components["schemas"]["ZigbeeRuleDefinition"];
            input?: {
                [key: string]: unknown;
            };
        } & (unknown | unknown);
        ZigbeeRuleSimulationResponse: {
            matched: boolean;
            actions: components["schemas"]["ZigbeeRuleAction"][];
            rule: components["schemas"]["ZigbeeRule"];
            evaluation: components["schemas"]["ZigbeeRuleSimulationEvaluation"];
        };
        ZigbeeRuleValidationResponse: {
            valid: boolean;
            normalized: components["schemas"]["ZigbeeRuleDefinition"];
            /** Format: date-time */
            evaluatedAt: string;
        };
        CameraEvent: {
            id: string;
            cameraId: string;
            cameraName: string;
            /** Format: date-time */
            timestamp: string;
            type: string;
            /** @enum {string} */
            severity: "info" | "warning" | "critical";
            /** Format: float */
            confidence: number;
            tags: string[];
            /** Format: uri */
            thumbnailUrl?: string | null;
            /** Format: uri */
            clipUrl?: string | null;
            clipAvailable: boolean;
            acknowledged: boolean;
            /** Format: date-time */
            acknowledgedAt?: string | null;
        };
        CameraEventClip: {
            /** Format: uri */
            url: string | null;
            /** Format: date-time */
            expiresAt: string | null;
            /** Format: int32 */
            durationSeconds: number | null;
            format: string | null;
        };
        CameraEventDetail: components["schemas"]["CameraEvent"] & {
            metadata: {
                [key: string]: unknown;
            };
            clip: components["schemas"]["CameraEventClip"];
        };
        CameraEventListResponse: {
            events: components["schemas"]["CameraEvent"][];
            pagination: {
                /** Format: int32 */
                total: number;
                /** Format: int32 */
                limit: number;
                nextCursor?: string | null;
                hasMore: boolean;
            };
            filters?: {
                cameraId?: string | null;
                /** Format: date-time */
                start?: string | null;
                /** Format: date-time */
                end?: string | null;
                tags?: string[];
                /** Format: float */
                minConfidence?: number | null;
                /** Format: float */
                maxConfidence?: number | null;
            } | null;
            /** Format: date-time */
            generatedAt: string;
        };
        CameraEventDetailResponse: {
            event: components["schemas"]["CameraEventDetail"];
            /** Format: date-time */
            retrievedAt: string;
        };
        CameraDevice: {
            id: string;
            name: string;
            status: components["schemas"]["DeviceStatus"];
            location?: string | null;
            /** Format: uri */
            streamUrl?: string | null;
            /** Format: uri */
            stillUrl?: string | null;
            /** Format: date-time */
            lastHeartbeat: string;
            /** @description Capabilities correspond to AI camera features documented in the device matrix. */
            capabilities: string[];
        };
        CameraClip: {
            id: string;
            cameraId: string;
            /** Format: date-time */
            start: string;
            /** Format: date-time */
            end: string;
            /** Format: uri */
            url: string;
            /** Format: uri */
            thumbnailUrl?: string | null;
            label?: string | null;
        };
        CameraPreviewState: {
            cameraId: string | null;
            /** @enum {string} */
            status: "ready" | "pending" | "unavailable";
            /** Format: uri */
            posterUrl: string | null;
            /** Format: uri */
            streamUrl: string | null;
            reason?: string | null;
            /** Format: date-time */
            updatedAt: string;
        };
        CameraStream: {
            id: string;
            name: string;
            /** @enum {string} */
            status: "online" | "offline" | "degraded";
            reason?: string | null;
            /** Format: uri */
            streamUrl?: string | null;
            module?: string | null;
            /** Format: date-time */
            updatedAt: string;
        };
        CameraStreamListResponse: {
            streams: components["schemas"]["CameraStream"][];
            /** Format: int32 */
            total: number;
            /** Format: date-time */
            updatedAt: string;
        };
        CameraOverviewSummary: {
            /** @enum {string} */
            status: "online" | "offline" | "degraded";
            /** Format: date-time */
            updatedAt: string;
            reason: string | null;
            cameras: {
                id: string;
                name: string;
                /** @enum {string} */
                status: "online" | "offline" | "degraded";
                /** Format: date-time */
                lastSeen?: string | null;
                reason?: string | null;
            }[];
        };
        CameraState: {
            activeCameraId: string | null;
            devices: components["schemas"]["CameraDevice"][];
            events: components["schemas"]["CameraEvent"][];
            clips: components["schemas"]["CameraClip"][];
            overview: {
                /** Format: uri */
                previewImage: string | null;
                /** Format: uri */
                streamUrl: string | null;
                /** Format: date-time */
                lastMotion: string | null;
                health: components["schemas"]["DeviceStatus"];
                /** Format: date-time */
                updatedAt: string | null;
            };
            /** @description Optional roll-up of camera health for quick status review. */
            summary?: components["schemas"]["CameraOverviewSummary"] | null;
            /** @description Preview metadata for the active camera if a live preview exists. */
            preview?: components["schemas"]["CameraPreviewState"] | null;
        };
        CameraSelectionRequest: {
            cameraId: string;
        };
        CameraClipRequest: {
            cameraId: string;
        };
        CameraClipResponse: {
            /** Format: uri */
            url: string;
        };
        LogEntry: {
            /** Format: date-time */
            timestamp: string;
            /** @enum {string} */
            level: "trace" | "debug" | "info" | "warn" | "error" | "fatal";
            message: string;
            meta?: {
                [key: string]: string;
            } | null;
            correlationId?: string | null;
            context?: {
                [key: string]: unknown;
            } | null;
        };
        LogSource: {
            id: string;
            label: string;
            description?: string | null;
            /** @enum {string} */
            kind: "device" | "service" | "system" | "group";
            module?: string | null;
            deviceId?: string | null;
            active?: boolean | null;
        };
        LogsSnapshot: {
            entries: components["schemas"]["LogEntry"][];
            sources?: components["schemas"]["LogSource"][];
            cursor?: string | null;
            /** Format: date-time */
            lastUpdated: string;
        };
        LogsExportRequest: {
            deviceId?: string;
            /** @enum {string} */
            level?: "trace" | "debug" | "info" | "warn" | "error" | "fatal";
            /** Format: date-time */
            start?: string;
            /** Format: date-time */
            end?: string;
            /**
             * @default json
             * @enum {string}
             */
            format: "json" | "csv";
        };
        LogsExportResponse: {
            exportId: string;
            /** @enum {string} */
            status: "queued" | "processing" | "completed" | "failed";
            /** @enum {string} */
            format: "json" | "csv";
            filters: {
                deviceId?: string | null;
                level?: string | null;
                /** Format: date-time */
                start?: string | null;
                /** Format: date-time */
                end?: string | null;
            };
            /** Format: date-time */
            requestedAt: string;
            /** Format: date-time */
            estimatedReadyAt: string;
            /** Format: uri */
            downloadUrl: string;
            correlationId?: string | null;
        };
        ProxySettings: {
            /** Format: uri */
            upstreamUrl: string;
            /** @enum {string} */
            authMode: "none" | "basic" | "token";
            /** Format: int32 */
            heartbeatIntervalSeconds: number;
        };
        ProxySettingsPatch: {
            /** Format: uri */
            upstreamUrl?: string;
            /** @enum {string} */
            authMode?: "none" | "basic" | "token";
            /** Format: int32 */
            heartbeatIntervalSeconds?: number;
        };
        SettingsPairingState: {
            active: boolean;
            /** Format: date-time */
            expiresAt: string | null;
            ticketId: string | null;
            candidates: {
                id: string;
                model: string;
                /** Format: int32 */
                signal: number;
            }[];
        };
        /** @enum {string} */
        OperatorRole: "admin" | "automation" | "viewer" | "incident" | "security";
        OperatorAccount: {
            id: string;
            /** Format: email */
            email: string;
            roles: components["schemas"]["OperatorRole"][];
            /** Format: date-time */
            invitedAt: string | null;
            /** @enum {string} */
            status: "active" | "pending" | "suspended";
            /** Format: date-time */
            lastUpdatedAt: string;
        };
        SettingsState: {
            proxy: components["schemas"]["ProxySettings"];
            allowedOrigins: string[];
            pairing: components["schemas"]["SettingsPairingState"];
            operators: components["schemas"]["OperatorAccount"][];
            apiTokenPreview: string;
            security: components["schemas"]["SecuritySettings"];
            /** Format: date-time */
            updatedAt: string | null;
        };
        ProxyUpdateRequest: {
            proxy: components["schemas"]["ProxySettingsPatch"];
        };
        AllowedOriginsRequest: {
            origins: string[];
        };
        PairingStartRequest: {
            /** @enum {string} */
            networkRole: "audio" | "video" | "lighting" | "sensor";
            /** Format: int32 */
            expiresInSeconds: number;
        };
        PairingClaimRequest: {
            alias?: string | null;
            location?: string | null;
            metadata?: {
                [key: string]: string;
            };
        };
        InviteOperatorRequest: {
            /** Format: email */
            email: string;
            roles: components["schemas"]["OperatorRole"][];
        };
        OperatorListResponse: {
            items: components["schemas"]["OperatorAccount"][];
            /** Format: int32 */
            total: number;
            /** Format: date-time */
            updatedAt: string;
        };
        OperatorUpdateRequest: {
            roles?: components["schemas"]["OperatorRole"][];
            /** @enum {string} */
            status?: "pending" | "active" | "suspended";
        };
        SecuritySettings: {
            nightMode: {
                escalationEnabled: boolean;
                alertChannels: ("slack" | "email" | "sms")[];
                /** Format: date-time */
                updatedAt: string;
            };
        };
        SecurityUpdateRequest: {
            nightMode: {
                escalationEnabled?: boolean;
                alertChannels?: ("slack" | "email" | "sms")[];
            };
        };
        FleetDeviceMetric: {
            id: string;
            label: string;
            value: string;
            unit?: string | null;
            /** @enum {string} */
            status: "ok" | "warn" | "error";
            /** @enum {string|null} */
            trend?: "up" | "down" | "steady" | null;
            /** Format: date-time */
            updatedAt?: string | null;
            description?: string | null;
        };
        FleetDeviceAction: {
            id: string;
            label: string;
            description?: string | null;
            /** @enum {string} */
            group: "audio" | "video" | "system" | "network" | "maintenance";
            /** @enum {string} */
            method: "POST" | "PATCH" | "DELETE";
            endpoint: string;
            requiresConfirmation?: boolean | null;
        };
        FleetDeviceAlert: {
            id: string;
            message: string;
            /** @enum {string} */
            severity: "info" | "warning" | "error";
            /** Format: date-time */
            createdAt: string;
            acknowledged: boolean;
        };
        FleetLayoutModule: {
            id: string;
            displayName: string;
            enabled: boolean;
            description?: string | null;
            capabilities: string[];
        };
        FleetLayout: {
            /** Format: date-time */
            updatedAt: string;
            modules: components["schemas"]["FleetLayoutModule"][];
        };
        FleetDeviceSummary: {
            id: string;
            name: string;
            role: string;
            module: string;
            status: components["schemas"]["DeviceStatus"];
            location?: string | null;
            /** Format: date-time */
            lastSeen: string;
            uptime: string;
            ipAddress: string;
            version: string;
            groups: string[];
            tags: string[];
            capabilities: string[];
        };
        FleetDeviceDetail: {
            summary: components["schemas"]["FleetDeviceSummary"];
            metrics: components["schemas"]["FleetDeviceMetric"][];
            alerts: components["schemas"]["FleetDeviceAlert"][];
            logs: components["schemas"]["LogEntry"][];
            actions: components["schemas"]["FleetDeviceAction"][];
            connections: {
                name: string;
                /** @enum {string} */
                status: "connected" | "pending" | "error";
                /** Format: date-time */
                lastChecked: string;
            }[];
        };
        FleetOverview: {
            totals: {
                /** Format: int32 */
                devices: number;
                /** Format: int32 */
                online: number;
                /** Format: int32 */
                offline: number;
                /** Format: int32 */
                degraded: number;
            };
            modules: {
                id: string;
                label: string;
                /** Format: int32 */
                online: number;
                /** Format: int32 */
                offline: number;
                /** Format: int32 */
                degraded: number;
            }[];
            devices: components["schemas"]["FleetDeviceSummary"][];
            /** Format: date-time */
            updatedAt: string;
        };
    };
    responses: {
        /** @description Authentication failed or credentials missing. */
        UnauthorizedError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Authenticated user does not have permission to access the resource. */
        ForbiddenError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Requested resource does not exist. */
        NotFoundError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description One or more request parameters failed validation. */
        ValidationError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Request rate limit exceeded. */
        RateLimitError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                "x-ratelimit-limit": components["headers"]["RateLimitLimit"];
                "x-ratelimit-remaining": components["headers"]["RateLimitRemaining"];
                "retry-after": components["headers"]["RetryAfterSeconds"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Upstream device returned an invalid response or is unreachable. */
        BadGatewayError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Upstream device timed out while processing the request. */
        GatewayTimeoutError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Unexpected server error occurred. */
        InternalError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Endpoint contract defined but backend implementation is pending. */
        NotImplementedError: {
            headers: {
                "x-correlation-id": components["headers"]["CorrelationId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
    };
    parameters: {
        /** @description Maximum number of results to return. */
        LimitParam: number;
        /** @description Opaque pagination cursor returned by previous responses. */
        CursorParam: string;
        /** @description Filter log entries to a specific severity level. */
        LogLevelParam: "trace" | "debug" | "info" | "warn" | "error" | "fatal";
        /** @description Limit log entries to a specific source identifier. */
        LogSourceParam: string;
        /** @description Free-text search filter applied to message and context fields. */
        LogSearchParam: string;
        /** @example text/event-stream */
        LogsStreamAccept: string;
    };
    requestBodies: never;
    headers: {
        /** @description Correlation identifier for tracing requests end-to-end. */
        CorrelationId: string;
        /** @description Maximum number of requests allowed in the current window. */
        RateLimitLimit: number;
        /** @description Remaining requests in the current window. */
        RateLimitRemaining: number;
        /** @description Seconds until clients may retry after a 429 response. */
        RetryAfterSeconds: number;
    };
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getFleetLayout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Fleet module layout describing enabled capabilities. */
            200: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FleetLayout"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    getFleetOverview: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Fleet-wide module and device summary. */
            200: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FleetOverview"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    getFleetDeviceDetail: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Detailed device view for operator troubleshooting. */
            200: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FleetDeviceDetail"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    triggerFleetDeviceAction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
                actionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Action accepted for asynchronous execution. */
            202: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            /** @description Device is busy and cannot accept the requested action. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    getAudioOverview: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Audio overview payload for the operator UI. */
            200: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioState"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    uploadAudioTrack: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** Format: binary */
                    file: string;
                    title: string;
                    artist?: string;
                    /** @description Comma-separated tags applied to the track. */
                    tags?: string;
                    /** Format: float */
                    durationSeconds?: number;
                };
            };
        };
        responses: {
            /** @description Track successfully uploaded. */
            201: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioLibraryTrack"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            /** @description Uploaded file exceeds allowed limits. */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    registerAudioUpload: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioLibraryUploadRegistrationRequest"];
            };
        };
        responses: {
            /** @description Upload registration created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioLibraryUploadRegistration"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    listAudioPlaylists: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Collection of playlists. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        items: components["schemas"]["AudioPlaylist"][];
                        /** Format: int32 */
                        total: number;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
        };
    };
    createAudioPlaylist: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioPlaylist"];
            };
        };
        responses: {
            /** @description Playlist created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioPlaylist"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    updateAudioPlaylist: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                playlistId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioPlaylist"];
            };
        };
        responses: {
            /** @description Updated playlist definition. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioPlaylist"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    reorderAudioPlaylist: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                playlistId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioPlaylistReorderRequest"];
            };
        };
        responses: {
            /** @description Playlist reordered successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioPlaylist"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    deleteAudioPlaylist: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                playlistId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Playlist removed. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    startAudioPlayback: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioPlaybackRequest"];
            };
        };
        responses: {
            /** @description Playback request accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    getAudioDevice: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Current device snapshot. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioDeviceSnapshot"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    pauseAudioDevice: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Pause command accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    listAudioPlaybackSessions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Collection of playback sessions. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        items: components["schemas"]["AudioSession"][];
                        /** Format: int32 */
                        total: number;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    createAudioPlaybackSession: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioPlaybackSessionCreateRequest"];
            };
        };
        responses: {
            /** @description Session started. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioSession"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    syncAudioPlaybackSession: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                sessionId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioSessionSyncRequest"];
            };
        };
        responses: {
            /** @description Drift update accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        sessions: components["schemas"]["AudioSession"][];
                        /** Format: date-time */
                        updatedAt: string;
                    };
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    resumeAudioDevice: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Resume command accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    stopAudioDevice: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Stop command accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    seekAudioDevice: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioSeekRequest"];
            };
        };
        responses: {
            /** @description Seek command accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    setAudioDeviceVolume: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioVolumeRequest"];
            };
        };
        responses: {
            /** @description Volume update accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    uploadAudioDeviceFallback: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** Format: binary */
                    file: string;
                };
            };
        };
        responses: {
            /** @description Fallback upload completed. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AudioDeviceUploadResponse"];
                };
            };
            /** @description Upload failed due to missing file or size limits. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    setAudioMasterVolume: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AudioMasterVolumeRequest"];
            };
        };
        responses: {
            /** @description Master volume update accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    listZigbeeRules: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Collection of automation rules. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeeRuleListResponse"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    createZigbeeRule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZigbeeRuleDefinition"];
            };
        };
        responses: {
            /** @description Automation rule created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeeRule"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    validateZigbeeRule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZigbeeRuleDefinition"];
            };
        };
        responses: {
            /** @description Validation outcome. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeeRuleValidationResponse"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    simulateZigbeeRule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZigbeeRuleSimulationRequest"];
            };
        };
        responses: {
            /** @description Simulation evaluation outcome. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeeRuleSimulationResponse"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    getZigbeeRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                ruleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Automation rule detail. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeeRule"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    updateZigbeeRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                ruleId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZigbeeRuleUpdateRequest"];
            };
        };
        responses: {
            /** @description Updated automation rule. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeeRule"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    deleteZigbeeRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                ruleId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Rule deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    toggleZigbeeRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                ruleId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    enabled?: boolean;
                };
            };
        };
        responses: {
            /** @description Updated automation rule status. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeeRule"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    getVideoOverview: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Video overview for the primary display node. */
            200: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoOverview"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    listVideoDevices: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Video device inventory. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        devices: components["schemas"]["VideoDeviceState"][];
                        /** Format: date-time */
                        updatedAt: string;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    setVideoPower: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    power: components["schemas"]["VideoPowerState"];
                };
            };
        };
        responses: {
            /** @description Power command accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        deviceId: string;
                        power: components["schemas"]["VideoPowerState"];
                        /** Format: date-time */
                        lastUpdated: string;
                    };
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    setVideoMute: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    mute: boolean;
                };
            };
        };
        responses: {
            /** @description Mute update accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        deviceId: string;
                        mute: boolean;
                        /** Format: date-time */
                        lastUpdated: string;
                    };
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    setVideoInput: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    input: string;
                };
            };
        };
        responses: {
            /** @description Input change accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        deviceId: string;
                        input: string;
                        /** Format: date-time */
                        lastUpdated: string;
                    };
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    exportVideoClip: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                recordingId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** Format: float */
                    startOffsetSeconds: number;
                    /** Format: float */
                    endOffsetSeconds: number;
                };
            };
        };
        responses: {
            /** @description Export request accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoClipExport"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    getVideoRecordings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Recording segments available for playback. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        items: components["schemas"]["VideoRecordingSegment"][];
                        /** Format: int32 */
                        total: number;
                        /** Format: date-time */
                        generatedAt: string;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    generateVideoPreview: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["VideoPreviewRequest"];
            };
        };
        responses: {
            /** @description Signed preview stream URL. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VideoPreviewSession"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    getZigbeeOverview: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Zigbee overview payload. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeeState"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
            502: components["responses"]["BadGatewayError"];
            504: components["responses"]["GatewayTimeoutError"];
        };
    };
    runZigbeeAction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ZigbeeActionRequest"];
            };
        };
        responses: {
            /** @description Action accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    startZigbeePairing: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ZigbeePairingStartRequest"];
            };
        };
        responses: {
            /** @description Pairing window started. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeePairingState"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    stopZigbeePairing: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Pairing mode stopped. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeePairingState"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    pollZigbeeDiscovered: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Discovered devices snapshot. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ZigbeePairingState"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    confirmZigbeePairing: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                deviceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Pairing confirmation accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
            501: components["responses"]["NotImplementedError"];
        };
    };
    getCameraSummary: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Camera overview payload. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraState"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    listCameraEvents: {
        parameters: {
            query?: {
                /** @description Return events that occurred at or after this timestamp. */
                start?: string;
                /** @description Return events that occurred at or before this timestamp. */
                end?: string;
                /** @description Restrict results to a single camera identifier. */
                cameraId?: string;
                /** @description Comma separated list of tags that must be present on the event. */
                tags?: string[];
                /** @description Minimum detection confidence (0.0-1.0 or percentage). */
                minConfidence?: number;
                /** @description Maximum detection confidence (0.0-1.0 or percentage). */
                maxConfidence?: number;
                /** @description Maximum number of events to return in a single response. */
                limit?: number;
                /** @description Cursor returned by a previous request for pagination. */
                cursor?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Camera event collection. */
            200: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraEventListResponse"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    acknowledgeCameraEvent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                eventId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event acknowledgement accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            422: components["responses"]["ValidationError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    getCameraPreview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                cameraId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Preview status response. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraPreviewState"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    listCameraStreams: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Camera stream collection. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CameraStreamListResponse"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    getLogs: {
        parameters: {
            query?: {
                /** @description Limit log entries to a specific source identifier. */
                source?: components["parameters"]["LogSourceParam"];
                /** @description Filter log entries to a specific severity level. */
                level?: components["parameters"]["LogLevelParam"];
                /** @description Free-text search filter applied to message and context fields. */
                q?: components["parameters"]["LogSearchParam"];
                /** @description Maximum number of results to return. */
                limit?: components["parameters"]["LimitParam"];
                /** @description Opaque pagination cursor returned by previous responses. */
                cursor?: components["parameters"]["CursorParam"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Logs snapshot response. */
            200: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogsSnapshot"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    streamLogs: {
        parameters: {
            query?: {
                /** @description Limit log entries to a specific source identifier. */
                source?: components["parameters"]["LogSourceParam"];
                /** @description Filter log entries to a specific severity level. */
                level?: components["parameters"]["LogLevelParam"];
                /** @description Free-text search filter applied to message and context fields. */
                q?: components["parameters"]["LogSearchParam"];
            };
            header?: {
                /** @example text/event-stream */
                accept?: components["parameters"]["LogsStreamAccept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Server-sent events stream of log entries. */
            200: {
                headers: {
                    /** @description Always text/event-stream for live updates. */
                    "content-type"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": string;
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    queryLogs: {
        parameters: {
            query?: {
                /** @description Filter log entries to a specific severity level. */
                level?: components["parameters"]["LogLevelParam"];
                /** @description Filter to a specific device identifier. */
                deviceId?: string;
                /** @description Filter by correlation identifier. */
                correlationId?: string;
                /** @description Filter logs from this timestamp onwards (ISO 8601). */
                start?: string;
                /** @description Filter logs up to this timestamp (ISO 8601). */
                end?: string;
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Filtered log entries. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        items: components["schemas"]["LogEntry"][];
                        /** Format: int32 */
                        total: number;
                        /** Format: date-time */
                        fetchedAt: string;
                    };
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            500: components["responses"]["InternalError"];
        };
    };
    exportLogs: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["LogsExportRequest"];
            };
        };
        responses: {
            /** @description Export scheduled. */
            202: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogsExportResponse"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    getLogExportJob: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The export job ID returned from the /logs/export endpoint. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Export job status and details. */
            200: {
                headers: {
                    "x-correlation-id": components["headers"]["CorrelationId"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogsExportResponse"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    getSettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Settings payload for the control plane. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SettingsState"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    updateProxySettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProxyUpdateRequest"];
            };
        };
        responses: {
            /** @description Proxy update accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        proxy: components["schemas"]["ProxySettings"];
                        /** Format: date-time */
                        updatedAt: string;
                    };
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    rotateApiToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Token rotation accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        status: string;
                        tokenPreview: string;
                        /** Format: date-time */
                        rotatedAt: string;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    updateAllowedOrigins: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AllowedOriginsRequest"];
            };
        };
        responses: {
            /** @description Allowed origins updated. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        allowedOrigins: string[];
                        /** Format: date-time */
                        updatedAt: string;
                    };
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    startSettingsPairing: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PairingStartRequest"];
            };
        };
        responses: {
            /** @description Pairing flow started. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SettingsPairingState"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    cancelSettingsPairing: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Pairing flow cancelled. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        cancelled: boolean;
                        /** Format: date-time */
                        updatedAt: string;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    claimPairingCandidate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                candidateId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["PairingClaimRequest"];
            };
        };
        responses: {
            /** @description Pairing candidate claim accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        accepted: boolean;
                        candidateId: string;
                        metadata: {
                            [key: string]: string;
                        };
                        /** Format: date-time */
                        updatedAt: string;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    listOperators: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Operator directory snapshot. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OperatorListResponse"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    inviteOperator: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["InviteOperatorRequest"];
            };
        };
        responses: {
            /** @description Operator invited. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OperatorAccount"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            /** @description Operator already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    updateOperator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                operatorId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OperatorUpdateRequest"];
            };
        };
        responses: {
            /** @description Operator updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OperatorAccount"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    removeOperator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                operatorId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Operator removal accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        removed: boolean;
                        operatorId: string;
                        /** Format: date-time */
                        updatedAt: string;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            404: components["responses"]["NotFoundError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    getSecuritySettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Security settings snapshot. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SecuritySettings"];
                };
            };
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
    updateSecuritySettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SecurityUpdateRequest"];
            };
        };
        responses: {
            /** @description Updated security settings. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SecuritySettings"];
                };
            };
            400: components["responses"]["ValidationError"];
            401: components["responses"]["UnauthorizedError"];
            403: components["responses"]["ForbiddenError"];
            429: components["responses"]["RateLimitError"];
            500: components["responses"]["InternalError"];
        };
    };
}