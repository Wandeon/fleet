services:
  audio-player:
    build:
      context: ../roles/audio-player/docker
      dockerfile: audio-player.Dockerfile
    restart: unless-stopped
    devices:
      - "/dev/snd:/dev/snd"
    group_add:
      - "audio"
    environment:
      - AUDIO_OUTPUT_DEVICE=${AUDIO_OUTPUT_DEVICE:-plughw:0,0}
      - AUDIO_VOLUME=${AUDIO_VOLUME:-1.0}
      - STREAM_URL=${STREAM_URL:-${ICECAST_SCHEME:-http}://${ICECAST_HOST}:${ICECAST_PORT:-8000}/${ICECAST_MOUNT}}
      - ICECAST_SCHEME=${ICECAST_SCHEME:-http}
      - ICECAST_HOST=${ICECAST_HOST:-}
      - ICECAST_PORT=${ICECAST_PORT:-8000}
      - ICECAST_MOUNT=${ICECAST_MOUNT:-}
      - FALLBACK_FILE=${FALLBACK_FILE:-/data/fallback.mp3}
    volumes:
      - audio_data:/data
    healthcheck:
      test: ["CMD-SHELL", "pgrep -f 'ffmpeg.*alsa' >/dev/null 2>&1"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 15s
    command:
      - sh
      - -lc
      - |
        set -e
        mkdir -p /app
        cat > /app/player.py <<"PY"
        import json
        import os
        import signal
        import subprocess
        import sys
        import time

        DATA = "/data"
        CFG_PATH = os.path.join(DATA, "config.json")
        STATE_PATH = os.path.join(DATA, "state.json")
        LOG_PATH = os.path.join(DATA, "player.log")
        OUT = os.environ.get("AUDIO_OUTPUT_DEVICE", "hw:0,0")
        DEF_URL = os.environ.get("STREAM_URL", "")
        try:
            DEFAULT_VOLUME = float(os.environ.get("AUDIO_VOLUME", "1.0"))
        except Exception:
            DEFAULT_VOLUME = 1.0
        FALLBACK = os.environ.get("FALLBACK_FILE", "/data/fallback.mp3")
        HEARTBEAT_INTERVAL = 1.0

        def _load_json(path, default):
            data = dict(default)
            try:
                with open(path, "r", encoding="utf-8") as handle:
                    loaded = json.load(handle)
                if isinstance(loaded, dict):
                    data.update(loaded)
            except Exception:
                pass
            return data

        def _save_json(path, payload):
            tmp_path = f"{path}.tmp"
            with open(tmp_path, "w", encoding="utf-8") as handle:
                json.dump(payload, handle)
            os.replace(tmp_path, path)

        def load_config():
            base = {
                "stream_url": DEF_URL,
                "volume": DEFAULT_VOLUME,
                "mode": "auto",
                "source": "stream",
            }
            return _load_json(CFG_PATH, base)

        def save_config(cfg):
            _save_json(CFG_PATH, cfg)

        def load_state():
            base = {
                "now_playing": "stop",
                "fallback_active": False,
                "fallback_exists": False,
                "stream_up": 0,
                "last_switch_timestamp": 0.0,
                "last_error": "",
            }
            return _load_json(STATE_PATH, base)

        def save_state(state):
            _save_json(STATE_PATH, state)

        def log_event(message):
            timestamp = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
            try:
                with open(LOG_PATH, "a", encoding="utf-8") as handle:
                    handle.write(f"{timestamp} {message}\n")
            except Exception:
                pass

        def play_ffmpeg(input_url, volume):
            args = [
                "ffmpeg",
                "-hide_banner",
                "-loglevel",
                "info",
                "-reconnect",
                "1",
                "-reconnect_streamed",
                "1",
                "-reconnect_on_network_error",
                "1",
                "-reconnect_delay_max",
                "2",
                "-i",
                input_url,
                "-vn",
                "-af",
                f"volume={volume}",
                "-c:a",
                "pcm_s16le",
                "-f",
                "alsa",
                OUT,
            ]
            return subprocess.Popen(args)

        def play_file_loop(path, volume):
            args = [
                "ffmpeg",
                "-hide_banner",
                "-loglevel",
                "info",
                "-stream_loop",
                "-1",
                "-re",
                "-i",
                path,
                "-vn",
                "-af",
                f"volume={volume}",
                "-c:a",
                "pcm_s16le",
                "-f",
                "alsa",
                OUT,
            ]
            return subprocess.Popen(args)

        def ffprobe_ok(url):
            try:
                result = subprocess.run(
                    [
                        "ffprobe",
                        "-v",
                        "error",
                        "-timeout",
                        "2000000",
                        "-i",
                        url,
                        "-of",
                        "json",
                        "-show_format",
                    ],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    timeout=4,
                    check=False,
                )
                return result.returncode == 0
            except Exception:
                return False

        def terminate_process(proc):
            if proc is None:
                return None
            if proc.poll() is None:
                proc.terminate()
                try:
                    proc.wait(timeout=2)
                except Exception:
                    proc.kill()
            return None

        def update_state(now_playing, fallback_exists, stream_up, last_switch_ts, last_error):
            payload = {
                "now_playing": now_playing,
                "fallback_active": now_playing == "file",
                "fallback_exists": bool(fallback_exists),
                "stream_up": 1 if stream_up else 0,
                "last_switch_timestamp": float(last_switch_ts),
                "last_error": last_error or "",
            }
            save_state(payload)

        def main():
            os.makedirs(DATA, exist_ok=True)
            cfg = load_config()
            save_config(cfg)
            state = load_state()
            last_switch = state.get("last_switch_timestamp", time.time()) or time.time()
            last_error = state.get("last_error", "")
            proc = None
            current = "stop"
            try:
                last_mtime = os.path.getmtime(CFG_PATH)
            except Exception:
                last_mtime = time.time()
            update_state(current, os.path.exists(FALLBACK), False, last_switch, last_error)

            while True:
                cfg = load_config()
                desired = str(cfg.get("source", "stream")).lower()
                try:
                    vol = float(cfg.get("volume", DEFAULT_VOLUME))
                except Exception:
                    vol = DEFAULT_VOLUME
                url = cfg.get("stream_url", DEF_URL)
                fallback_exists = os.path.exists(FALLBACK)
                mode = str(cfg.get("mode", "auto")).lower()
                auto_mode = mode == "auto"

                try:
                    mt = os.path.getmtime(CFG_PATH)
                except FileNotFoundError:
                    mt = last_mtime
                if mt != last_mtime:
                    log_event("configuration change detected; restarting pipeline")
                    proc = terminate_process(proc)
                    current = "stop"
                    last_mtime = mt
                    last_switch = time.time()

                stream_up = False

                if desired == "stop":
                    if current != "stop":
                        log_event("stopping playback (requested)")
                    proc = terminate_process(proc)
                    current = "stop"
                    stream_up = False
                    last_error = ""
                elif desired == "file" or (auto_mode and (not url or not ffprobe_ok(url))):
                    if not fallback_exists:
                        if current != "stop":
                            proc = terminate_process(proc)
                            current = "stop"
                            last_switch = time.time()
                        last_error = "fallback file missing"
                        update_state(current, fallback_exists, False, last_switch, last_error)
                        time.sleep(2)
                        continue
                    if current != "file":
                        proc = terminate_process(proc)
                        log_event("switching to fallback file playback")
                        proc = play_file_loop(FALLBACK, vol)
                        current = "file"
                        last_switch = time.time()
                    if desired != "file" and auto_mode:
                        last_error = "stream unavailable, playing fallback"
                    else:
                        last_error = ""
                    stream_up = False
                else:
                    if current != "stream":
                        proc = terminate_process(proc)
                        log_event(f"starting stream playback: {url}")
                        proc = play_ffmpeg(url, vol)
                        current = "stream"
                        last_switch = time.time()
                    stream_up = proc is not None and proc.poll() is None
                    last_error = ""

                update_state(current, fallback_exists, stream_up and current == "stream", last_switch, last_error)

                time.sleep(HEARTBEAT_INTERVAL)

                if proc is not None and proc.poll() is not None:
                    rc = proc.returncode
                    log_event(f"playback process exited (rc={rc})")
                    last_error = f"playback exited (rc={rc})"
                    proc = None
                    if current != "stop":
                        current = "stop"
                        last_switch = time.time()
                    update_state(current, os.path.exists(FALLBACK), False, last_switch, last_error)

        if __name__ == "__main__":
            signal.signal(signal.SIGTERM, lambda _s, _f: sys.exit(0))
            main()
        PY
        exec python3 /app/player.py

  audio-control:
    build:
      context: ../roles/audio-player/docker
      dockerfile: audio-control.Dockerfile
    restart: unless-stopped
    ports:
      - "8081:8081"
    environment:
      - CONTROL_BIND=0.0.0.0
      - CONTROL_PORT=8081
      - AUDIO_DATA_DIR=/data
      - AUTH_TOKEN=${AUDIO_CONTROL_TOKEN:-}
      - MIXER_CARD=${AUDIO_MIXER_CARD:-0}
      - MIXER_CONTROL=${AUDIO_MIXER_CONTROL:-Master}
    volumes:
      - audio_data:/data
    healthcheck:
      test: ["CMD-SHELL", "python3 - <<'PY'\nimport urllib.request,sys; urllib.request.urlopen('http://127.0.0.1:8081/healthz', timeout=2); sys.exit(0)\nPY"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 10s
    command:
      - sh
      - -lc
      - |
        set -e
        # Flask and dependencies are preinstalled in the image
        mkdir -p /app
        cat > /app/app.py <<"PY"
        import json
        import logging
        import os
        import re
        import subprocess

        from flask import Flask, Response, jsonify, request

        BIND = os.environ.get("CONTROL_BIND", "0.0.0.0")
        PORT = int(os.environ.get("CONTROL_PORT", "8081"))
        DATA = os.environ.get("AUDIO_DATA_DIR", "/data")
        CFG = os.path.join(DATA, "config.json")
        STATE = os.path.join(DATA, "state.json")
        FB = os.path.join(DATA, "fallback.mp3")
        TOKEN = os.environ.get("AUTH_TOKEN", "")
        MIXER_CARD = os.environ.get("MIXER_CARD", "0")
        MIXER_CONTROL = os.environ.get("MIXER_CONTROL", "Master")

        VALID_SOURCES = {"stream", "file", "stop"}
        VALID_MODES = {"auto", "manual"}

        app = Flask(__name__)
        app.config["JSONIFY_PRETTYPRINT_REGULAR"] = False

        os.makedirs(DATA, exist_ok=True)

        LOG_PATH = os.path.join(DATA, "control.log")
        _handler = logging.FileHandler(LOG_PATH)
        _handler.setLevel(logging.INFO)
        _handler.setFormatter(logging.Formatter("%(asctime)s %(levelname)s %(message)s"))
        app.logger.addHandler(_handler)
        app.logger.setLevel(logging.INFO)
        app.logger.propagate = False

        def _load_json(path, default):
            data = dict(default)
            try:
                with open(path, "r", encoding="utf-8") as handle:
                    loaded = json.load(handle)
                if isinstance(loaded, dict):
                    data.update(loaded)
            except Exception:
                pass
            return data

        def _save_json(path, payload):
            tmp = f"{path}.tmp"
            with open(tmp, "w", encoding="utf-8") as handle:
                json.dump(payload, handle)
            os.replace(tmp, path)

        def load_config():
            base = {"stream_url": "", "volume": 1.0, "mode": "auto", "source": "stream"}
            return _load_json(CFG, base)

        def save_config(cfg):
            _save_json(CFG, cfg)

        def load_state():
            base = {
                "now_playing": "stop",
                "fallback_active": False,
                "fallback_exists": False,
                "stream_up": 0,
                "last_switch_timestamp": 0.0,
                "last_error": "",
            }
            return _load_json(STATE, base)

        def save_state(state):
            _save_json(STATE, state)

        def _authed():
            if not TOKEN:
                return True
            auth = request.headers.get("Authorization", "")
            return auth.startswith("Bearer ") and auth.split(" ", 1)[1] == TOKEN

        @app.before_request
        def _guard():
            if request.path in ("/healthz",):
                return None
            if not _authed():
                return jsonify({"error": "unauthorized"}), 401

        def _bad_request(message):
            return jsonify({"error": message}), 400

        def _clamp_volume(value):
            return max(0.0, min(2.0, value))

        def _escape_label(value):
            return value.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")

        @app.get("/status")
        def status():
            cfg = load_config()
            state = load_state()
            fallback_exists = os.path.exists(FB) or bool(state.get("fallback_exists"))
            now_playing = state.get("now_playing", cfg.get("source", "stream"))
            response = dict(cfg)
            response["requested_source"] = cfg.get("source")
            response["fallback_exists"] = bool(fallback_exists)
            response["now_playing"] = now_playing
            response["fallback_active"] = bool(state.get("fallback_active", now_playing == "file"))
            response["stream_up"] = 1 if state.get("stream_up") else 0
            response["last_switch_timestamp"] = float(state.get("last_switch_timestamp", 0.0))
            last_error = state.get("last_error")
            if last_error:
                response["last_error"] = last_error
            return jsonify(response)

        @app.get("/config")
        def get_cfg():
            return jsonify(load_config())

        @app.put("/config")
        def put_cfg():
            data = request.get_json(force=True) or {}
            cfg = load_config()
            updates = {}
            if "stream_url" in data:
                stream_url = data.get("stream_url") or ""
                if not isinstance(stream_url, str):
                    return _bad_request("stream_url must be a string")
                updates["stream_url"] = stream_url
            if "volume" in data:
                try:
                    volume = float(data.get("volume"))
                except Exception:
                    return _bad_request("volume must be numeric")
                updates["volume"] = _clamp_volume(volume)
            if "mode" in data:
                mode = str(data.get("mode", "")).lower()
                if mode not in VALID_MODES:
                    return _bad_request("mode must be one of auto|manual")
                updates["mode"] = mode
            if "source" in data:
                source = str(data.get("source", "")).lower()
                if source not in VALID_SOURCES:
                    return _bad_request("source must be one of stream|file|stop")
                updates["source"] = source
            if updates:
                cfg.update(updates)
                save_config(cfg)
                app.logger.info("PUT /config updated keys: %s", sorted(updates.keys()))
            return jsonify(cfg)

        @app.post("/volume")
        def volume():
            data = request.get_json(force=True) or {}
            try:
                value = float(data.get("volume"))
            except Exception:
                return _bad_request("volume must be numeric")
            value = _clamp_volume(value)
            cfg = load_config()
            cfg["volume"] = value
            save_config(cfg)
            app.logger.info("POST /volume -> %.2f", value)
            return jsonify(cfg)

        @app.post("/play")
        def play():
            data = request.get_json(force=True) or {}
            source = str(data.get("source", "stream")).lower()
            if source not in VALID_SOURCES:
                return _bad_request("source must be one of stream|file|stop")
            cfg = load_config()
            cfg["source"] = source
            if "mode" in data:
                mode = str(data.get("mode", "")).lower()
                if mode not in VALID_MODES:
                    return _bad_request("mode must be one of auto|manual")
                cfg["mode"] = mode
            if "stream_url" in data:
                stream_url = data.get("stream_url") or ""
                if not isinstance(stream_url, str):
                    return _bad_request("stream_url must be a string")
                cfg["stream_url"] = stream_url
            save_config(cfg)
            app.logger.info("POST /play -> source=%s mode=%s", cfg.get("source"), cfg.get("mode"))
            return jsonify(cfg)

        @app.post("/stop")
        def stop():
            cfg = load_config()
            cfg["source"] = "stop"
            save_config(cfg)
            app.logger.info("POST /stop -> stop")
            return jsonify(cfg)

        @app.post("/upload")
        def upload():
            if "file" not in request.files:
                return _bad_request("missing file")
            file_obj = request.files["file"]
            os.makedirs(DATA, exist_ok=True)
            file_obj.save(FB)
            size = 0
            try:
                size = os.path.getsize(FB)
            except Exception:
                size = 0
            app.logger.info("POST /upload -> saved fallback (%s bytes)", size)
            return jsonify({"saved": True, "path": FB})

        @app.get("/healthz")
        def healthz():
            return "ok"

        def _amixer_cmd(*args):
            return ["amixer", "-c", str(MIXER_CARD), *args]

        def _get_hw_vol():
            try:
                output = subprocess.check_output(_amixer_cmd("get", MIXER_CONTROL), text=True)
                match = re.search(r"\[(\d+)%\]", output)
                if match:
                    return int(match.group(1))
            except Exception:
                pass
            return None

        @app.get("/hwvolume")
        def hwvolume_get():
            volume = _get_hw_vol()
            return jsonify({"mixer_card": int(MIXER_CARD), "mixer_control": MIXER_CONTROL, "volume_percent": volume})

        @app.post("/hwvolume")
        def hwvolume_set():
            data = request.get_json(force=True) or {}
            try:
                value = int(data.get("volume_percent", 100))
            except Exception:
                return _bad_request("volume_percent must be numeric")
            value = max(0, min(100, value))
            try:
                subprocess.check_call(_amixer_cmd("set", MIXER_CONTROL, f"{value}%"))
            except Exception as exc:
                return (str(exc), 500)
            app.logger.info("POST /hwvolume -> %s%%", value)
            return jsonify({"ok": True, "volume_percent": value})

        @app.get("/metrics")
        def metrics():
            cfg = load_config()
            state = load_state()
            fallback_exists = os.path.exists(FB) or bool(state.get("fallback_exists"))
            now_playing = state.get("now_playing", cfg.get("source", "stop"))
            fallback_active = 1 if state.get("fallback_active") or now_playing == "file" else 0
            stream_up = 1 if state.get("stream_up") else 0
            last_switch = float(state.get("last_switch_timestamp", 0.0))
            last_error = state.get("last_error", "")
            mode = str(cfg.get("mode", "auto")).lower()
            requested = str(cfg.get("source", "stream")).lower()
            try:
                volume = float(cfg.get("volume", 1.0))
            except Exception:
                volume = 1.0
            lines = []
            lines.append("# HELP audio_volume Software volume (0.0-2.0)")
            lines.append("# TYPE audio_volume gauge")
            lines.append(f"audio_volume {volume}")
            lines.append("# HELP audio_fallback_exists Whether fallback file exists on disk")
            lines.append("# TYPE audio_fallback_exists gauge")
            lines.append(f"audio_fallback_exists {1 if fallback_exists else 0}")
            lines.append("# HELP audio_fallback_active Indicates fallback playback is active")
            lines.append("# TYPE audio_fallback_active gauge")
            lines.append(f"audio_fallback_active {fallback_active}")
            lines.append("# HELP audio_stream_up Indicates if the stream playback is active")
            lines.append("# TYPE audio_stream_up gauge")
            lines.append(f"audio_stream_up {stream_up}")
            lines.append("# HELP audio_last_switch_timestamp Unix timestamp of the last playback source switch")
            lines.append("# TYPE audio_last_switch_timestamp gauge")
            lines.append(f"audio_last_switch_timestamp {last_switch}")
            lines.append("# HELP audio_source_state Requested playback source selection")
            lines.append("# TYPE audio_source_state gauge")
            for src in ("stream", "file", "stop"):
                lines.append(f"audio_source_state{{source=\"{src}\"}} {1 if requested == src else 0}")
            lines.append("# HELP audio_now_playing_state Current playback state reported by the player loop")
            lines.append("# TYPE audio_now_playing_state gauge")
            for src in ("stream", "file", "stop"):
                lines.append(f"audio_now_playing_state{{state=\"{src}\"}} {1 if now_playing == src else 0}")
            lines.append("# HELP audio_mode_state Requested playback mode selector")
            lines.append("# TYPE audio_mode_state gauge")
            for mode_name in ("auto", "manual"):
                lines.append(f"audio_mode_state{{mode=\"{mode_name}\"}} {1 if mode == mode_name else 0}")
            lines.append("# HELP audio_player_state_info Info metric capturing the last player error message")
            lines.append("# TYPE audio_player_state_info gauge")
            lines.append(f"audio_player_state_info{{last_error=\"{_escape_label(last_error or '')}\"}} 1")
            return Response("\n".join(lines) + "\n", mimetype="text/plain")

        if __name__ == "__main__":
            if not os.path.exists(CFG):
                save_config(load_config())
            if not os.path.exists(STATE):
                save_state(load_state())
            app.logger.info("audio-control starting on %s:%s", BIND, PORT)
            app.run(host=BIND, port=PORT)
        PY
        exec python3 /app/app.py

volumes:
  audio_data: {}
